<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" DocStrap Classes GithubReleaseNotes Global clearTasksconvertStringToArraydashToCamelCaseformatDategetBashOptionsisInRangeprintTaskrepotasktokenuser Source: utils.js 'use strict'; var chalk = require('chalk'); /** * Print a task name in a custom format * * @since 0.5.0 * @public * * @param {string} name The name of the task */ function printTask(name) { process.stdout.write(chalk.blue(name + ' task:\\n===================================\\n')); } /** * Outputs the task status * * @since 0.5.0 * @public * * @param {string} taskName The task name * * @return {Function} The function to be fired when is loaded */ function task(gren, taskName) { var time = process.hrtime(); process.stdout.write(chalk.green(taskName) + ': .'); gren.tasks[taskName] = setInterval(function() { process.stdout.write('.'); }, 100); return function(message) { var diff = process.hrtime(time); var seconds = ((diff[0] * 1e9 + diff[1]) * 1e-9).toFixed(2); process.stdout.write(message || '' + chalk.yellow(' (' + seconds + ' secs)\\n')); clearInterval(gren.tasks[taskName]); gren.tasks[taskName] = seconds; }; } /** * Clears all the tasks that are still running * * @since 0.6.0 * @public * * @param {GithubReleaseNotes} gren */ function clearTasks(gren) { if (!gren.tasks.length) { return; } Object.keys(gren.tasks).forEach(function(taskName) { clearInterval(gren.tasks[taskName]); }); process.stdout.write(chalk.red('\\nTask(s) stopped because of the following error:\\n')); gren.tasks = []; } /** * Check if e value is between a min and a max * * @since 0.5.0 * @public * * @param {number} value * @param {number} min * @param {number} max * * @return {Boolean} */ function isInRange(value, min, max) { return !Math.floor((value - min) / (max - min)); } /** * Transforms a dasherize string into a camel case one. * * @since 0.3.2 * @public * * @param {string} value The dasherize string * * @return {string} The camel case string */ function dashToCamelCase(value) { return value .toLowerCase() .replace(/-([a-z])/g, function(match) { return match[1].toUpperCase(); }); } /** * Create a literal object of the node module options * * @since 0.1.0 * @public * * @param {Array} args The array of arguments (the module arguments start from index 2) * * @return {Object} The object containg the key/value options */ function getBashOptions(args) { var settings = {}; for (var i = 2; i &lt; args.length; i++) { var paramArray = args[i].split('='); var key = paramArray[0].replace('--', ''); var value = paramArray[1]; settings[dashToCamelCase(key)] = value || true; } return settings; } /** * Converts an array like string to an actual Array, * converting also underscores to spaces * * @since 0.6.0 * @public * * @param {string} arrayLike The string of items * e.g. * &quot;wont_fix, duplicate, bug&quot; * * @return {Array} The items with spaces instead of underscores. */ function convertStringToArray(arrayLike) { if (!arrayLike) { return []; } if (typeof arrayLike === 'object') { return Object.keys(arrayLike).map(function(itemKey) { return arrayLike[itemKey]; }); } return arrayLike .replace(/\\s/g, '') .split(',') .map(function(itemName) { return itemName.replace(/_/g, ' ', itemName); }); } /** * Format a date into a string * * @since 0.5.0 * @public * * @param {Date} date * @return {string} */ function formatDate(date) { return ('0' + date.getDate()).slice(-2) + '/' + ('0' + (date.getMonth() + 1)).slice(-2) + '/' + date.getFullYear(); } module.exports = { printTask: printTask, task: task, clearTasks: clearTasks, getBashOptions: getBashOptions, dashToCamelCase: dashToCamelCase, isInRange: isInRange, convertStringToArray: convertStringToArray, formatDate: formatDate }; Ã— Search results Close "},"gren.js.html":{"id":"gren.js.html","title":"Source: gren.js","body":" DocStrap Classes GithubReleaseNotes Global clearTasksconvertStringToArraydashToCamelCaseformatDategetBashOptionsisInRangeprintTaskrepotasktokenuser Source: gren.js 'use strict'; var utils = require('./utils'); var githubInfo = require('./github-info'); var template = require('./template'); var Github = require('github-api'); var fs = require('fs'); var chalk = require('chalk'); var Promise = Promise || require('es6-promise').Promise; var connectivity = require('connectivity'); var templateConfig = require('./templates.json'); var ObjectAssign = require('deep-assign'); var configFile = fs.existsSync(process.cwd() + '/.gren.json') ? require(process.cwd() + '/.gren.json') : {}; var defaults = { tags: false, timeWrap: 'latest', // || history changelogFilename: 'CHANGELOG.md', dataSource: 'issues', // || commits draft: false, force: false, prefix: '', includeMessages: 'commits', // || merges || all prerelease: false, dateZero: new Date(0), override: false, ignoredLabels: false, // || array of labels ignoreIssuesWith: false, // || array of labels template: templateConfig }; /** * Edit a release from a given tag (in the options) * * @since 0.5.0 * @private * * @param {GithubReleaseNotes} gren The gren object * @param {number} releaseId The id of the release to edit * @param {Object} releaseOptions The options to build the release: * @example * { * &quot;tag_name&quot;: &quot;v1.0.0&quot;, * &quot;target_commitish&quot;: &quot;master&quot;, * &quot;name&quot;: &quot;v1.0.0&quot;, * &quot;body&quot;: &quot;Description of the release&quot;, * &quot;draft&quot;: false, * &quot;prerelease&quot;: false * } * * @return {Promise} */ function editRelease(gren, releaseId, releaseOptions) { var loaded = utils.task(gren, 'Updating latest release'); return gren.repo.updateRelease(releaseId, releaseOptions) .then(function(response) { loaded(); var release = response.data; console.log(chalk.green('\\n\\n' + release.name + ' has been successfully updated!')); return release; }); } /** * Create a release from a given tag (in the options) * * @since 0.1.0 * @private * * @param {GithubReleaseNotes} gren The gren object * @param {Object} releaseOptions The options to build the release: * @example { * &quot;tag_name&quot;: &quot;1.0.0&quot;, * &quot;target_commitish&quot;: &quot;master&quot;, * &quot;name&quot;: &quot;v1.0.0&quot;, * &quot;body&quot;: &quot;Description of the release&quot;, * &quot;draft&quot;: false, * &quot;prerelease&quot;: false * } * * @return {Promise} */ function createRelease(gren, releaseOptions) { var loaded = utils.task(gren, 'Preparing the release'); return gren.repo.createRelease(releaseOptions) .then(function(response) { loaded(); var release = response.data; console.log(chalk.green('\\n\\n' + release.name + ' has been successfully created!')); return release; }); } /** * Creates the options to make the release * * @since 0.2.0 * @private * * @param {GithubReleaseNotes} gren The gren object * @param {Object[]} tags The collection of tags * * @return {Promise} */ function prepareRelease(gren, block) { var releaseOptions = { tag_name: block.release, name: block.name, body: block.body, draft: gren.options.draft, prerelease: gren.options.prerelease }; if (block.id) { return editRelease(gren, block.id, releaseOptions); } return createRelease(gren, releaseOptions); } /** * Get the tags information from the given ones, and adds * the next one in case only one is given * * @since 0.5.0 * @private * * @param {Boolean|Array} selectedTags * @param {Object[]} tags * * @return {Boolean|Array} */ function getSelectedTags(optionTags, tags) { if (!optionTags.length) { return false; } var selectedTags = [].concat(optionTags); return tags.filter(function(tag, index) { var isSelectedTag = selectedTags.indexOf(tag.name) !== -1; if (isSelectedTag &amp;&amp; selectedTags.length === 1 &amp;&amp; tags[index + 1]) { selectedTags.push(tags[index + 1].name); } return isSelectedTag; }).slice(0, 2); } /** * Get all the tags of the repo * * @since 0.1.0 * @private * * @param {GithubReleaseNotes} gren The gren object * * @return {Promise} */ function getLastTags(gren, releases) { var loaded = utils.task(gren, 'Getting tags'); return gren.repo.listTags() .then(function(response) { loaded(); var tags = response.data; var filteredTags = (getSelectedTags(gren.options.tags, tags) || [tags[0], tags[1]]) .map(function(tag) { var tagRelease = releases &amp;&amp; releases.filter(function(release) { return release.tag_name === tag.name; })[0] || false; var releaseId = tagRelease ? tagRelease.id : null; return { tag: tag, releaseId: releaseId }; }); if (filteredTags[0].releaseId &amp;&amp; !gren.options.override) { throw chalk.red(filteredTags[0].tag.name + ' is a release, use --override flag to override an existing release!'); } console.log('Tags found: ' + filteredTags.map(function(tag) { return tag.tag.name; }).join(', ')); return filteredTags; }); } /** * Get the dates of the last two tags * * @since 0.1.0 * @private * * @param {GithubReleaseNotes} gren The gren object * @param {Object[]} tags List of all the tags in the repo * * @return {Promise[]} The promises which returns the dates */ function getTagDates(gren, tags) { return tags.map(function(tag) { return gren.repo.getCommit(tag.tag.commit.sha) .then(function(response) { return { id: tag.releaseId, name: tag.tag.name, date: response.data.committer.date }; }); }); } /** * Get all releases * * @since 0.5.0 * @private * * @param {Object[]} releases A list of release Objects * * @return {Array} The list of the dates */ function getReleaseDates(gren, releases) { return [].concat(releases).map(function(release) { return { id: release.id, name: release.name, tag_name: release.tag_name, date: release.created_at, body: release.body || null }; }); } /** * Get all releases * * @since 0.5.0 * @private * * @param {GithubReleaseNotes} gren The gren object * * @return {Promise} The promise which resolves an array of releases */ function getListReleases(gren) { var loaded = utils.task(gren, 'Getting the list of releases'); return gren.repo.listReleases() .then(function(response) { loaded(); var releases = response.data; process.stdout.write(releases.length + ' releases found\\n'); return releases; }); } /** * Get the latest releases * * @since 0.5.0 * @private * * @param {GithubReleaseNotes} gren The gren object * * @return {Promise} The promise which resolves the tag name of the release */ function getLastTwoReleases(gren) { return getListReleases(gren) .then(function(releases) { return releases.slice(0, 2); }); } /** * Return a string with a - to be a bulvar list (used for a mapping) * * @since 0.1.0 * @private * * @param {string} message * * @return {string} */ function templateCommits(gren, message) { return template.generate({ message: message }, gren.options.template.commit); } /** * Generate the MD template from all the labels of a specific issue * * @since 0.5.0 * @private * * @param {Object} issue * * @return {string} */ function templateLabels(gren, issue) { if (!issue.labels.length) { issue.labels.push({name: 'closed'}); } return issue.labels .filter(function(label) { return gren.options.ignoredLabels.indexOf(label.name) === -1; }) .map(function(label) { return template.generate({ label: label.name }, gren.options.template.issueInfo.label); }).join(''); } /** * Generate the MD template a block * * @since 0.5.0 * @private * * @param {Object} block ({name: 'v1.2.3', body: []}) * * @return {string} */ function templateBlock(gren, block) { var date = new Date(block.date); var releaseTemplate = template.generate({ release: block.name, date: utils.formatDate(date) }, template.generate(gren.options.template.releaseInfo, gren.options.template.release)); return releaseTemplate + '\\n\\n' + block.body; } /** * Generate the MD template for each issue * * @since 0.5.0 * @private * * @param {Object} issue * * @return {string} */ function templateIssue(gren, issue) { var issueTemplate = template.generate(gren.options.template.issueInfo, gren.options.template.issue); var nameTemplate = template.generate({ name: issue.title }, gren.options.template.issueInfo.name); return template.generate({ labels: templateLabels(gren, issue), name: nameTemplate, text: '#' + issue.number, url: issue.html_url }, issueTemplate); } /** * Generate the Changelog MD template * * @since 0.5.0 * @private * * @param {Object[]} blocks * * @return {string} */ function templateChangelog(gren, blocks) { return '# Changelog\\n\\n' + blocks .map(templateBlock.bind(null, gren)) .join('\\n\\n --- \\n\\n'); } /** * Generate the Changelog issues body template * * @since 0.5.0 * @private * * @param {Object[]} blocks * * @return {string} */ function templateIssueBody(body, rangeBody) { return (body.length ? body.join('\\n') : rangeBody || '*No changelog for this release.*') + '\\n'; } /** * Return a commit messages generated body * * @since 0.1.0 * @private * * @param {string} message * * @return {string} */ function generateCommitsBody(gren, messages) { return messages .slice(0, -1) .filter(function(message) { var messageType = gren.options.includeMessages; var filterMap = { merges: function(message) { return message.match(/^merge/i); }, commits: function(message) { return !message.match(/^merge/i); }, all: function() { return true; } }; if (filterMap[messageType]) { return filterMap[messageType](message); } return filterMap.commits(message); }) .map(templateCommits.bind(null, gren)) .join('\\n'); } /** * Transforms the commits to commit messages * * @since 0.1.0 * @private * * @param {Object[]} commits The array of object containing the commits * * @return {String[]} */ function commitMessages(commits) { return commits.map(function(commitObject) { return commitObject.commit.message; }); } /** * Gets all the commits between two dates * * @since 0.1.0 * @private * * @param {GithubReleaseNotes} gren The gren object * @param {string} since The since date in ISO * @param {string} until The until date in ISO * * @return {Promise} The promise which resolves the [Array] commit messages */ function getCommitsBetweenTwo(gren, since, until) { process.stdout.write(chalk.green('Get commits between ' + utils.formatDate(new Date(since)) + ' and ' + utils.formatDate(new Date(until)) + '\\n')); var options = { since: since, until: until, per_page: 100 }; return gren.repo.listCommits(options) .then(function(commits) { return commitMessages(commits); }); } /** * Get the blocks of commits based on release dates * * @since 0.5.0 * @private * * @param {GithubReleaseNotes} gren * @param {Array} releaseRanges The array of date ranges * * @return {Promise[]} */ function getCommitBlocks(gren, releaseRanges) { console.log(chalk.blue('\\nCreating the body blocks from commits:')); return Promise.all( releaseRanges .map(function(range) { return getCommitsBetweenTwo(gren, range[1].date, range[0].date) .then(function(commits) { return { id: range[0].id, release: range[0].name, date: range[0].date, body: generateCommitsBody(gren, commits) + '\\n' }; }); }) ); } /** * Compare the ignored labels with the passed ones * * @since 0.6.0 * @private * * @param {Array} ignoredLabels The labels to ignore * @param {Array} labels The labels to check * * @return {boolean} If the labels array contain any of the ignore ones */ function compareIssueLabels(ignoredLabels, labels) { return ignoredLabels .reduce(function(carry, ignoredLabel) { return carry &amp;&amp; labels.map(function(label) { return label.name; }).indexOf(ignoredLabel) === -1; }, true); } /** * Get all the closed issues from the current repo * * @since 0.5.0 * @private * * @param {GithubReleaseNotes} gren The gren object * @param {Array} releaseRanges The array of date ranges * * @return {Promise} The promise which resolves the list of the issues */ function getClosedIssues(gren, releaseRanges) { var loaded = utils.task(gren, 'Getting all closed issues'); return gren.issues.listIssues({ state: 'closed', since: releaseRanges[releaseRanges.length - 1][1].date }) .then(function(response) { loaded(); var filteredIssues = response.data.filter(function(issue) { return !issue.pull_request &amp;&amp; compareIssueLabels(gren.options.ignoreIssuesWith, issue.labels); }); process.stdout.write(filteredIssues.length + ' issues found\\n'); return filteredIssues; }); } /** * Get the blocks of issues based on release dates * * @since 0.5.0 * @private * * @param {GithubReleaseNotes} gren * @param {Array} releaseRanges The array of date ranges * * @return {Promise[]} */ function getIssueBlocks(gren, releaseRanges) { console.log('\\nCreating the body blocks from releases:'); return getClosedIssues(gren, releaseRanges) .then(function(issues) { return releaseRanges .map(function(range) { var body = (!range[0].body || gren.options.override) &amp;&amp; issues.filter(function(issue) { return utils.isInRange( Date.parse(issue.closed_at), Date.parse(range[1].date), Date.parse(range[0].date) ); }) .map(templateIssue.bind(null, gren)); return { id: range[0].id, release: range[0].name, name: gren.options.prefix + range[0].name, date: range[0].date, body: templateIssueBody(body, range[0].body) }; }); }); } /** * Sort releases by dates * * @since 0.5.0 * @private * * @param {Array} releaseDates * * @return {Array} */ function sortReleasesByDate(releaseDates) { return releaseDates.sort(function(release1, release2) { return new Date(release2.date) - new Date(release1.date); }); } /** * Create the ranges of release dates * * @since 0.5.0 * @private * * @param {GithubReleaseNotes} gren * @param {Array} releaseDates The release dates * * @return {Array} */ function createReleaseRanges(gren, releaseDates) { var ranges = []; var range = 2; var sortedReleaseDates = sortReleasesByDate(releaseDates); if (sortedReleaseDates.length === 1 || gren.options.timeWrap === 'history') { sortedReleaseDates.push({ id: 0, date: new Date(0) }); } for (var i = 0; i &lt; sortedReleaseDates.length - 1; i++) { ranges.push(sortedReleaseDates.slice(i, i + range)); } return ranges; } /** * Generate a CHANGELOG.md file based on Time and issues * * @since 0.5.0 * @private * * @return {Promise[]} */ function generateReleaseDatesChangelogBody(gren) { var releaseActions = { history: getListReleases, latest: getLastTwoReleases }; var dataSource = { issues: getIssueBlocks, commits: getCommitBlocks }; return releaseActions[gren.options.timeWrap](gren) .then(function(releases) { if (releases.length === 0) { throw chalk.red('There are no releases! Run gren to generate release notes'); } var releaseRanges = createReleaseRanges(gren, getReleaseDates(gren, releases)); return dataSource[gren.options.dataSource](gren, releaseRanges); }) .then(function(blocks) { return templateChangelog(gren, blocks); }); } /** * Create the CHANGELOG.md file * * @since 0.5.0 * @private * * @param {string} body * * @return {boolean} */ function createChangelog(gren, body) { function createFile(fileBody) { fs.writeFile(gren.options.changelogFilename, fileBody, function(err) { if (err) { throw err; } process.stdout.write('\\n' + chalk.green('The changelog file has been saved!\\n')); return true; }); } try { fs.readFile(gren.options.changelogFilename, 'utf-8', function(err, data) { if (err) { console.error(chalk.red(err)); return; } var newReleaseName = body.match(/(##\\s[\\w\\s.]+)/)[0]; if (data.match(newReleaseName)) { if (gren.options.force) { createFile(body + '\\n\\n --- \\n\\n' + data.replace(/^(#\\s?\\w*\\n\\n)/g, '')); return true; } else if (gren.options.override) { createFile(body); return true; } console.error(chalk.red('\\nThis release is already in the changelog\\n')); return false; } createFile(body + '\\n --- \\n\\n' + data.replace(/^(#\\s?\\w*\\n\\n)/g, '')); }); } catch (e) { createFile(body); } } /** * Generate the GithubReleaseNotes getting the options from the git config * * @since 0.5.0 * @private * * @return {Promise[]} */ function generateOptions(options) { return Promise.all([ options.user ? Promise.resolve(options.user) : githubInfo.user(), options.repo ? Promise.resolve(options.repo) : githubInfo.repo(), options.token ? Promise.resolve(options.token) : githubInfo.token() ]); } /** * Check if there is connectivity * * @since 0.5.0 * @private * * @return {Promise} */ function hasNetwork() { return new Promise(function(resolve, reject) { connectivity(function(isOnline) { if (!isOnline) { reject(chalk.red('You need to have network connectivity')); return; } resolve(); }); }); } /** * @param {Object} [options] The options of the module * * @since 0.1.0 * @public * * @constructor */ function GithubReleaseNotes(options) { this.options = ObjectAssign({}, defaults, configFile, options || utils.getBashOptions(process.argv)); this.options.tags = utils.convertStringToArray(this.options.tags); this.options.ignoredLabels = utils.convertStringToArray(this.options.ignoredLabels); this.options.ignoreIssuesWith = utils.convertStringToArray(this.options.ignoreIssuesWith); this.repo = null; this.issues = null; this.isEditingLatestRelease = false; } /** * Initialise the GithubReleaseNotes module, create the options and run * a given module method * * @since 0.5.0 * @public * * @param {function} action * * @return {Promise} The generated options */ GithubReleaseNotes.prototype.init = function() { var gren = this; gren.tasks = []; return hasNetwork() .then(function() { return generateOptions(gren.options); }) .then(function(optionData) { gren.options = ObjectAssign(...optionData, gren.options); if (!gren.options.token) { throw chalk.red('You need to provide the token'); } var githubApi = new Github({ token: gren.options.token }); gren.repo = githubApi.getRepo(gren.options.username, gren.options.repo); gren.issues = githubApi.getIssues(gren.options.username, gren.options.repo); }); }; /** * Get All the tags, get the dates, get the commits between those dates and prepeare the release * * @since 0.1.0 * @public * * @return {Promise} */ GithubReleaseNotes.prototype.release = function() { utils.printTask('\\nRelease'); var loaded; var gren = this; var dataSource = { issues: getIssueBlocks, commits: getCommitBlocks }; return getListReleases(this) .then(function(releases) { return getLastTags(gren, releases.length ? releases : false); }) .then(function(tags) { loaded = utils.task(gren, 'Getting the tag dates ranges'); return Promise.all(getTagDates(gren, tags)); }) .then(function(releaseDates) { loaded(); return dataSource[gren.options.dataSource]( gren, createReleaseRanges(gren, releaseDates) ); }) .then(function(blocks) { return prepareRelease(gren, blocks[0]); }); }; /** * Generate the Changelog * * @since 0.5.0 * @public * * @param {string} type The type of changelog */ GithubReleaseNotes.prototype.changelog = function() { utils.printTask('\\nChangelog'); var gren = this; return generateReleaseDatesChangelogBody(this) .then(function(changelogBody) { return createChangelog(gren, changelogBody); }) .then(function(success) { return success; }); }; module.exports = GithubReleaseNotes; Ã— Search results Close "},"github-info.js.html":{"id":"github-info.js.html","title":"Source: github-info.js","body":" DocStrap Classes GithubReleaseNotes Global clearTasksconvertStringToArraydashToCamelCaseformatDategetBashOptionsisInRangeprintTaskrepotasktokenuser Source: github-info.js 'use strict'; var exec = require('child_process').exec; var chalk = require('chalk'); var Promise = Promise || require('es6-promise').Promise; /** * Execute a command in the bash and run a callback * * @since 0.5.0 * @private * * @param {string} command The command to execute * @param {Function} callback The callback which returns the stdout * * @return {Promise} */ function executeCommand(command, callback) { return new Promise(function(resolve, reject) { exec(command, function(err, stdout, stderr) { if (err || stderr) { reject(err || stderr); } else { resolve(stdout.replace('\\n', '')); } }); }) .then(callback) .catch(function(error) { throw new Error(chalk.red(error) + chalk.yellow('Make sure you\\'re running the command from the repo folder, or you using the --username and --repo flags.')); }); } /** * Get user informations * * @since 0.5.0 * @public * * @param {Function} callback * * @return {Promise} The promise that resolves user informations ({ user: username}) */ function user(callback) { return executeCommand('git config user.name', function(user) { return { user: user }; }) .then(callback); } /** * Get repo informations * * @since 0.5.0 * @public * * @param {Function} callback * * @return {Promise} The promise that resolves repo informations ({user: user, name: name}) */ function repo(callback) { return executeCommand('git config remote.origin.url', function(repo) { var repoPath = repo .replace(/([^:]*:)|\\.[^.]+$/g, '') .split('/'); var user = repoPath[0]; var name = repoPath[1]; return { username: user, repo: name }; }) .then(callback); } /** * Get token informations * * @since 0.5.0 * @public * * @param {Function} callback * * @return {Promise} The promise that resolves token informations ({token: token}) */ function token(callback) { return executeCommand('echo $GREN_GITHUB_TOKEN', function(token) { return { token: token }; }) .then(callback); } module.exports = { user: user, repo: repo, token: token }; Ã— Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Classes GithubReleaseNotes Global clearTasksconvertStringToArraydashToCamelCaseformatDategetBashOptionsisInRangeprintTaskrepotasktokenuser Global Methods clearTasks(gren) Clears all the tasks that are still running Parameters: Name Type Description gren GithubReleaseNotes Since: 0.6.0 Source: utils.js, line 53 convertStringToArray(arrayLike) Converts an array like string to an actual Array,converting also underscores to spaces Parameters: Name Type Description arrayLike string The string of itemse.g.&quot;wont_fix, duplicate, bug&quot; Since: 0.6.0 Source: utils.js, line 138 Returns: The items with spaces instead of underscores. Type Array dashToCamelCase(value) Transforms a dasherize string into a camel case one. Parameters: Name Type Description value string The dasherize string Since: 0.3.2 Source: utils.js, line 93 Returns: The camel case string Type string formatDate(date) Format a date into a string Parameters: Name Type Description date Date Since: 0.5.0 Source: utils.js, line 166 Returns: Type string getBashOptions(args) Create a literal object of the node module options Parameters: Name Type Description args Array The array of arguments (the module arguments start from index 2) Since: 0.1.0 Source: utils.js, line 111 Returns: The object containg the key/value options Type Object isInRange(value, min, max) Check if e value is between a min and a max Parameters: Name Type Description value number min number max number Since: 0.5.0 Source: utils.js, line 79 Returns: Type Boolean printTask(name) Print a task name in a custom format Parameters: Name Type Description name string The name of the task Since: 0.5.0 Source: utils.js, line 13 repo(callback) Get repo informations Parameters: Name Type Description callback function Since: 0.5.0 Source: github-info.js, line 63 Returns: The promise that resolves repo informations ({user: user, name: name}) Type Promise task(taskName) Outputs the task status Parameters: Name Type Description taskName string The task name Since: 0.5.0 Source: utils.js, line 26 Returns: The function to be fired when is loaded Type function token(callback) Get token informations Parameters: Name Type Description callback function Since: 0.5.0 Source: github-info.js, line 89 Returns: The promise that resolves token informations ({token: token}) Type Promise user(callback) Get user informations Parameters: Name Type Description callback function Since: 0.5.0 Source: github-info.js, line 44 Returns: The promise that resolves user informations ({ user: username}) Type Promise Ã— Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Classes GithubReleaseNotes Global clearTasksconvertStringToArraydashToCamelCaseformatDategetBashOptionsisInRangeprintTaskrepotasktokenuser Classes Classes GithubReleaseNotes Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Classes GithubReleaseNotes Global clearTasksconvertStringToArraydashToCamelCaseformatDategetBashOptionsisInRangeprintTaskrepotasktokenuser Github Release Notes Node module that generates release notes based on commit messages or closed issues between tags. It also can create a full changelog or add the latest release notes to the existing changelog file. If you want to include it in a task, you can use grunt-github-release-notes InstallationInstall github-release-notes via npm: npm install github-release-notes -gUsagegren can be ran through the terminal, but before you can use it, you need to set up a couple of things. Github Informationsgren by default looks for your local git configuration to get the repo informations. This means you can run the command directly from the git repo folder. Otherwise, you can run it from wherever and specify a different repo as target, with: gren --username=[username] --repo=[repo name]TokenTo work, gren needs a github token (that can be easily generated following this link). You only need &quot;repo&quot; scope. Once generated, you can run the gren command with the token as variable: gren --token=your_token_hereOr you can add it to your ~/.bash_profile or ~/.zshrc) as follows: export GREN_GITHUB_TOKEN=your_token_hereAnd you're ready to use it! Just run this command in your terminal: grenThe module will look for the last tag, get all the issues closed in the time between that tag and the one before, and it will build release notes and draft the new release! OptionsFollowing the options for the module: --action=release|changelog The gren action to run. Default: release (see details below for changelog generator) --tags=0.1.0|0.2.0,0.1.0 A specific tag or the range of tags to build the release notes from. --ignore-labels=wont_fix|wont_fix,duplicate One or more labels to ignore in the output. Default: false (it will still output the issue, just without the specified labels) --ignore-issues-with=wont_fix|wont_fix,duplicate Ignore issues that contains one of the specified issues. Default: false --time-wrap=latest|history The release notes you want to include in the changelog. Default: latest Only applicable to the changelog action --changelog-filename=CHANGELOG.md The name of the changelog file. Default: CHANGELOG.md --data-source=issues|commits The informations you want to use to build release notes. Default: issues --draft=true|false To set the release as a draft. Default: false --prerelease=true|false To set the release as a prerelease. Default: false --prefix=v Add a prefix to the tag version e.g. v1.0.1. Default: null --include-messages=merges|commits|all used to filter the messages added to the release notes. Default: commits --override=true|false Override the release notes if existing. Default: false Config fileYou can create a .gren.json file where the task will be ran, where to specify your options.The options in the file would be camelCase e.g: { &quot;action&quot;: &quot;release&quot;, &quot;timeWrap&quot;: &quot;history&quot;, &quot;dataSource&quot;: &quot;commits&quot;, &quot;ignoreIssuesWith&quot;: [ &quot;wontfix&quot;, &quot;duplicate&quot; ] }TemplatesWith gren you can decide how you want to output the informations, using the templates. The default configuration is the following: { &quot;...&quot;: &quot;...&quot;, &quot;template&quot;: { &quot;commit&quot;: &quot;- {{message}}&quot;, &quot;issue&quot;: &quot;- {{labels}} {{name}} {{link}}&quot;, &quot;issueInfo&quot;: { &quot;labels&quot;: &quot;{{labels}}&quot;, &quot;label&quot;: &quot;[**{{label}}**]&quot;, &quot;name&quot;: &quot;{{name}}&quot;, &quot;link&quot;: &quot;[{{text}}]({{url}})&quot; }, &quot;release&quot;: &quot;## {{release}} {{date}}&quot;, &quot;releaseInfo&quot;: { &quot;release&quot;: &quot;{{release}}&quot;, &quot;date&quot;: &quot;({{date}})&quot; } } }To customise the templates you need to change the .gren.json config file. You only need to specify what you want to change e.g. { &quot;template&quot;: { &quot;issue&quot;: &quot;- {{name}}&quot; } }ExamplesThe ways to use gren are various. SimpleThe simple way, just looks for the last tag, gets all the issues closed between that tag and the one before and creates the new release with the generated body. grenCommit messagesAdding the flag --data-source=commits will change the source of the release notes to be the commit messages. gren --data-source=commitsRelease specific tagsThe flag --tags accepts one or two tags.If you only give one tag, it will get the issues (or commit messages) between that tag and the one before.If you give two tags it will generate the release notes with the issues (or commit messages) between those two tag dates. gren --tags=2.0.0,1.0.0Override an existing releaseIf you trying to create an existing release, gren will throw an error &quot;0.3.0 is a release, use --override flag to override an existing release!If you want then to override, simple use: gren --override --tags=0.3.0Changelog Generatorgren can also update generate the changelog. The following command, will generate the release notes for the latest release, and add it to an existing file or create it in the same directory where you run the command. gren --action=changelogThe generated release notes will be added at the top of the file, and will look like this: Changelogv0.4.3 (02/03/2016)[bug] This is a issue name #123 Generate a full changelogIf tou want to generate the whole changelog, you need to use the --time-wrap=history. This will generate a changelog based on issues (or on commit messages if the --data-source=commits is present). If you want to override the existing changelog, use --override. The usage would then be: gren --time-wrap=history --overrideTo see a full example of the changelog here CHANGELOG.md Ã— Search results Close "},"GithubReleaseNotes.html":{"id":"GithubReleaseNotes.html","title":"Class: GithubReleaseNotes","body":" DocStrap Classes GithubReleaseNotes Global clearTasksconvertStringToArraydashToCamelCaseformatDategetBashOptionsisInRangeprintTaskrepotasktokenuser Class: GithubReleaseNotes GithubReleaseNotes new GithubReleaseNotes( [options]) Parameters: Name Type Argument Description options Object &lt;optional&gt; The options of the module Since: 0.1.0 Source: gren.js, line 785 Methods changelog(type) Generate the Changelog Parameters: Name Type Description type string The type of changelog Since: 0.5.0 Source: gren.js, line 879 init(action) Initialise the GithubReleaseNotes module, create the options and runa given module method Parameters: Name Type Description action function Since: 0.5.0 Source: gren.js, line 806 Returns: The generated options Type Promise release() Get All the tags, get the dates, get the commits between those dates and prepeare the release Since: 0.1.0 Source: gren.js, line 839 Returns: Type Promise Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
